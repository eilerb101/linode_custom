#!/bin/sh
# Metadata-driven OPNsense Configuration Script
# Place in: /usr/local/etc/rc.syshook.d/start/00-metadata-config
CONFIG_FILE="/conf/config.xml"
BACKUP_FILE="/conf/config.xml.backup"
LOG_TAG="metadata-config"
KEY=""
SECRET=""


# Function to log messages
log_msg() {
    logger -t "$LOG_TAG" "$1"
    echo "$1"
}

# Function to calculate network address from IP/CIDR
calculate_network() {
    local ip=$1
    local bits=$2
    local IFS='.'
    set -- $ip
    local ip1=$1 ip2=$2 ip3=$3 ip4=$4
    
    # Calculate mask
    local mask=$((0xffffffff << (32 - bits) & 0xffffffff))
    local m1=$(( (mask >> 24) & 0xff ))
    local m2=$(( (mask >> 16) & 0xff ))
    local m3=$(( (mask >> 8) & 0xff ))
    local m4=$(( mask & 0xff ))
    
    # Calculate network address
    local n1=$(( ip1 & m1 ))
    local n2=$(( ip2 & m2 ))
    local n3=$(( ip3 & m3 ))
    local n4=$(( ip4 & m4 ))
    
    echo "${n1}.${n2}.${n3}.${n4}:${m1}.${m2}.${m3}.${m4}"
}

# Function to calculate broadcast address
calculate_broadcast() {
    local ip=$1
    local bits=$2
    local IFS='.'
    set -- $ip
    local ip1=$1 ip2=$2 ip3=$3 ip4=$4
    
    # Calculate inverse mask
    local mask=$((0xffffffff << (32 - bits) & 0xffffffff))
    local inv_mask=$((~mask & 0xffffffff))
    
    # Calculate broadcast
    local host_mask=$((0xffffffff << (32 - bits) & 0xffffffff))
    local n1=$(( (ip1 & (host_mask >> 24 & 0xff)) | (inv_mask >> 24 & 0xff) ))
    local n2=$(( (ip2 & (host_mask >> 16 & 0xff)) | (inv_mask >> 16 & 0xff) ))
    local n3=$(( (ip3 & (host_mask >> 8 & 0xff)) | (inv_mask >> 8 & 0xff) ))
    local n4=$(( (ip4 & (host_mask & 0xff)) | (inv_mask & 0xff) ))
    
    echo "${n1}.${n2}.${n3}.${n4}"
}

# Function to add to last octet
add_to_ip() {
    local ip=$1
    local add=$2
    local IFS='.'
    set -- $ip
    echo "${1}.${2}.${3}.$(($4 + add))"
}

log_msg "Starting metadata configuration..."

# Backup existing config
cp "$CONFIG_FILE" "$BACKUP_FILE"

# Get metadata token
log_msg "Fetching metadata token..."
TOKEN=$(curl -s --max-time 10 -X PUT -H 'Metadata-Token-Expiry-Seconds: 3600' http://[fd00:a9fe:a9fe::1]/v1/token)

if [ -z "$TOKEN" ]; then
    log_msg "ERROR: Failed to obtain metadata token"
    exit 1
fi

log_msg "Token obtained successfully"

# Get network information
log_msg "Fetching network metadata..."
NETWORK_DATA=$(curl -s --max-time 10 -H "Metadata-Token: $TOKEN" http://[fd00:a9fe:a9fe::1]/v1/network)

if [ -z "$NETWORK_DATA" ]; then
    log_msg "ERROR: Failed to fetch network metadata"
    exit 1
fi

# Extract first IPAM address (CIDR)
CIDR=$(echo "$NETWORK_DATA" | awk -F': ' '/interfaces\.ipam_address/ {print $2; exit}')

if [ -z "$CIDR" ]; then
    log_msg "ERROR: No IPAM address found in metadata"
    exit 1
fi

log_msg "Found CIDR: $CIDR"

# Split CIDR into IP and BITS
IP=$(echo "$CIDR" | cut -d'/' -f1)
BITS=$(echo "$CIDR" | cut -d'/' -f2)

log_msg "IP: $IP, BITS: $BITS"

# Calculate network and mask
CALC_RESULT=$(calculate_network "$IP" "$BITS")
NETWORK=$(echo "$CALC_RESULT" | cut -d':' -f1)
MASK=$(echo "$CALC_RESULT" | cut -d':' -f2)

log_msg "NETWORK: $NETWORK, MASK: $MASK"

# Calculate IP addresses
ROUTER=$(add_to_ip "$NETWORK" 1)
ROUTER_A=$(add_to_ip "$NETWORK" 2)
ROUTER_B=$(add_to_ip "$NETWORK" 3)
RDS=$(add_to_ip "$NETWORK" 4)
START=$(add_to_ip "$NETWORK" 10)

# Calculate END (broadcast - 6)
BROADCAST=$(calculate_broadcast "$IP" "$BITS")
END=$(add_to_ip "$BROADCAST" -6)

log_msg "ROUTER: $ROUTER"
log_msg "ROUTER_A: $ROUTER_A"
log_msg "ROUTER_B: $ROUTER_B"
log_msg "RDS: $RDS"
log_msg "START: $START"
log_msg "END: $END"

# Get region
log_msg "Fetching region metadata..."
INSTANCE_DATA=$(curl -s --max-time 10 -H "Metadata-Token: $TOKEN" http://[fd00:a9fe:a9fe::1]/v1/instance)
REGION=$(echo "$INSTANCE_DATA" | awk -F': ' '/region/ {print $2}')

if [ -z "$REGION" ]; then
    log_msg "ERROR: Failed to fetch region"
    exit 1
fi

# Normalize region to lowercase
REGION=$(echo "$REGION" | tr '[:upper:]' '[:lower:]')
log_msg "Region: $REGION"

# Map region to REGIONID
case "$REGION" in
    "nl-ams") REGIONID=22 ;;
    "us-southeast") REGIONID=4 ;;
    "in-maa") REGIONID=25 ;;
    "us-ord") REGIONID=18 ;;
    "us-central") REGIONID=2 ;;
    "eu-central") REGIONID=10 ;;
    "de-fra-2") REGIONID=47 ;;
    "us-west") REGIONID=3 ;;
    "id-cgk") REGIONID=29 ;;
    "eu-west") REGIONID=7 ;;
    "gb-lon") REGIONID=44 ;;
    "us-lax") REGIONID=30 ;;
    "es-mad") REGIONID=24 ;;
    "au-mel") REGIONID=45 ;;
    "us-mia") REGIONID=28 ;;
    "it-mil") REGIONID=27 ;;
    "ap-west") REGIONID=14 ;;
    "in-bom-2") REGIONID=46 ;;
    "us-east") REGIONID=6 ;;
    "jp-osa") REGIONID=26 ;;
    "fr-par") REGIONID=19 ;;
    "br-gru") REGIONID=21 ;;
    "us-sea") REGIONID=20 ;;
    "ap-south") REGIONID=9 ;;
    "sg-sin-2") REGIONID=48 ;;
    "se-sto") REGIONID=23 ;;
    "ap-southeast") REGIONID=16 ;;
    "ap-northeast") REGIONID=11 ;;
    "jp-tyo-3") REGIONID=49 ;;
    "ca-central") REGIONID=15 ;;
    "us-iad") REGIONID=17 ;;
    *) 
        log_msg "ERROR: Unknown region: $REGION"
        exit 1
        ;;
esac

log_msg "Region ID: $REGIONID"

# Get active IPv4
ACTIVEIP=$(echo "$NETWORK_DATA" | awk -F': ' '/ipv4\.public/ {print $2; exit}')

# Remove /32 suffix if present
ACTIVEIP=$(echo "$ACTIVEIP" | cut -d'/' -f1)
log_msg "Active IP: $ACTIVEIP"

# Check for shared IP
SHAREDIP=$(echo "$NETWORK_DATA" | awk -F': ' '/ipv4\.shared/ {print $2; exit}')

if [ -n "$SHAREDIP" ]; then
    MODE="standby"
    SHAREDIP=$(echo "$SHAREDIP" | cut -d'/' -f1)
    log_msg "Shared IP found: $SHAREDIP, MODE: standby"
else
    MODE="active"
    log_msg "No shared IP found, MODE: active"
fi

# Set mode dependent vars
if [ "$MODE" = "standby" ]; then
 # Calculate gateway from SHAREDIP (first 3 octets + .1)
    GATEWAY=$(echo ${SHAREDIP} | cut -d. -f1-3).1
    EXT_VIP=${SHAREDIP}
    CARP_PEER=${ROUTER_A}
    SKEW="100"
    HOSTNAME="${REGION}-B"
    LAN_IP=${ROUTER_B}
else
 # Calculate gateway from ACTIVEIP (first 3 octets + .1)
    GATEWAY=$(echo ${ACTIVEIP} | cut -d. -f1-3).1
    EXT_VIP=${ACTIVEIP}
    CARP_PEER=${ROUTER_B}
    SKEW="0"
    HOSTNAME="${REGION}-A"
    LAN_IP=${ROUTER_A}
fi
log_msg "Updating VIPs..."
###START VIP CONFIGS
# Fetch current VIP configuration
response=$(curl -k -X GET -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/interfaces/vip_settings/get")

# Find CARP VIP with vhid=1 on LAN
found_uuid=""
needs_update=0
echo "found UUID $found_uuid"
# Extract all VIP UUIDs
uuids=$(echo "$response" | jq -r '.vip.vip | keys[]' 2>/dev/null)

if [ -n "$uuids" ]; then
    for uuid in $uuids; do
     ###Check if this VIP is CARP mode
        is_carp=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".mode.carp.selected" 2>/dev/null)

        if [ "$is_carp" = "1" ]; then
            # Check if it's on LAN
            is_lan=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".interface.lan.selected" 2>/dev/null)

            if [ "$is_lan" = "1" ]; then
                # Check vhid
                vhid=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".vhid" 2>/dev/null)

                if [ "$vhid" = "1" ]; then
                    found_uuid="$uuid"
                    # Check subnet
                    subnet=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".subnet" 2>/dev/null)
                    if [ "$subnet" != "$ROUTER" ]; then
                        need_update=1
                        break
                    fi
                    # Check subnet_bits
                    subnet_bits=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".subnet_bits" 2>/dev/null)
                    if [ "$subnet_bits" != "$BITS" ]; then
                        needs_update=1
                        break
                    fi
                    # Check peer
                    peer=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".peer" 2>/dev/null)
                    if [ "$peer" != "$CARP_PEER" ]; then
                        needs_update=1
                        break
                    fi
                    # All checks passed
                    echo "CARP VIP is correctly configured"
                    break
                fi
            fi
        fi
    done
fi
# Delete existing VIP if found but incorrect
if [ -n "$found_uuid" ] && [ "$needs_update" = "1" ]; then
    echo "Deleting incorrect CARP VIP: $found_uuid"
    curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/interfaces/vip_settings/del_item/$found_uuid"
    found_uuid=""
fi

# Create VIP if it doesn't exist or was deleted
if [ -z "$found_uuid" ] || [ "$needs_update" = "1" ]; then
    echo "Creating CARP VIP"
    curl -k -u "$KEY:$SECRET" -H "Content-Type: application/json" -X POST "https://127.0.0.1:8087/api/interfaces/vip_settings/add_item" --data-raw "{\"vip\":{\"interface\":\"lan\",\"mode\":\"carp\",\"subnet\":\"${ROUTER}\",\"subnet_bits\":\"${BITS}\",\"password\":\"L1n0d3\",\"vhid\":\"1\",\"advbase\":\"1\",\"advskew\":\"${SKEW}\",\"peer\":\"${CARP_PEER}\",\"nosync\":\"0\",\"address\":\"${ROUTER}/${BITS}\",\"descr\":\"CARP VIP\"}}"
fi
# Check for IP Alias VIP on lo0
found_alias_uuid=""
needs_alias_update=0
if [ -n "$uuids" ]; then
    for uuid in $uuids; do
        # Check if this VIP is IP Alias mode
        is_ipalias=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".mode.ipalias.selected" 2>/dev/null)
        if [ "$is_ipalias" = "1" ]; then
            # Check if it's on lo0
            is_lo0=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".interface.lo0.selected" 2>/dev/null)
            if [ "$is_lo0" = "1" ]; then
                found_alias_uuid="$uuid"
#Check subnet
                subnet=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".subnet" 2>/dev/null)
                if [ "$subnet" != "$EXT_VIP" ]; then
                   needs_alias_update=1
                    break
                fi
                # Check subnet_bits
                subnet_bits=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".subnet_bits" 2>/dev/null)
                if [ "$subnet_bits" != "32" ]; then
                    needs_alias_update=1
                    break
                fi

                # Check gateway
                gateway=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".gateway" 2>/dev/null)
                if [ "$gateway" != "$GATEWAY" ]; then
                    needs_alias_update=1
                    break
                fi
                # Check address
                address=$(echo "$response" | jq -r ".vip.vip.\"$uuid\".address" 2>/dev/null)
                if [ "$address" != "${EXT_VIP}/32" ]; then
                    needs_alias_update=1
                    break
                fi
                # All checks passed
                echo "IP Alias VIP is correctly configured"
                break
            fi
        fi
    done
fi
# Delete existing IP Alias VIP if found but incorrect
if [ -n "$found_alias_uuid" ] && [ "$needs_alias_update" = "1" ]; then
    echo "Deleting incorrect IP Alias VIP: $found_alias_uuid"
    curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/interfaces/vip_settings/del_item/$found_alias_uuid"
    found_alias_uuid=""
fi
# Create IP Alias VIP if it doesn't exist or was deleted
if [ -z "$found_alias_uuid" ] || [ "$needs_alias_update" = "1" ]; then
    echo "Creating IP Alias VIP"
    curl -k -u "$KEY":"$SECRET" -H "Content-Type: application/json" -X POST "https://127.0.0.1:8087/api/interfaces/vip_settings/add_item" --data-raw "{\"vip\":{\"interface\":\"lo0\",\"mode\":\"ipalias\",\"subnet\":\"${EXT_VIP}\",\"subnet_bits\":\"32\",\"gateway\":\"${GATEWAY}\",\"advbase\":\"1\",\"advskew\":\"0\",\"nosync\":\"0\",\"address\":\"${EXT_VIP}/32\",\"descr\":\"SharedIP\"}}"
fi
###END VIP CONFIG
####START BGP UPDATES
log_msg "Updating BGP..."
curl -k -u "$KEY:$SECRET" -H "Content-Type: application/json" -X POST "https://127.0.0.1:8087/api/quagga/bgp/set" --data-raw "{\"bgp\":{\"enabled\":\"1\",\"asnumber\":\"65001\",\"distance\":\"\",\"routerid\":\"${ACTIVEIP}\",\"graceful\":\"0\",\"networks\":\"${EXT_VIP}/32\",\"bestpath\":\"as-path multipath-relax\",\"networkimportcheck\":\"0\",\"enforce_first_as\":\"1\",\"logneighborchanges\":\"1\"}}"
# Fetch BGP configuration
bgp_response=$(curl -k -X GET -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/bgp/get")

# Expected peer group UUID
EXPECTED_PEERGROUP="6f3386f0-6f54-4508-a6e5-c256d51b35c0"

# Track if any changes were made
bgp_changed=0
# Deduplicate neighbors - keep only the first occurrence of each address
neighbor_uuids=$(echo "$bgp_response" | jq -r '.bgp.neighbors.neighbor | keys[]' 2>/dev/null)

if [ -n "$neighbor_uuids" ]; then
    # Track addresses we've seen
    seen_addresses=""
    
    for uuid in $neighbor_uuids; do
        neighbor_addr=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".address" 2>/dev/null)
        
        # Check if we've seen this address before
        if echo "$seen_addresses" | grep -qw "$neighbor_addr"; then
            echo "Deleting duplicate BGP neighbor: $uuid ($neighbor_addr)"
            curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/bgp/del_neighbor/${uuid}"
            sleep 1
            bgp_changed=1
        else
            # Add to seen addresses
            seen_addresses="$seen_addresses $neighbor_addr"
        fi
    done
    
    # Re-fetch BGP configuration after deduplication
    if [ "$bgp_changed" = "1" ]; then
        bgp_response=$(curl -k -X GET -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/bgp/get")
    fi
fi

# Function to validate and create/update BGP neighbor
validate_bgp_neighbor() {
    peer_num=$1
    target_address="2600:3c0f:${REGIONID}:34::${peer_num}"
    
    found_uuid=""
    needs_update=0
    # Extract all neighbor UUIDs
    neighbor_uuids=$(echo "$bgp_response" | jq -r '.bgp.neighbors.neighbor | keys[]' 2>/dev/null)
    
    if [ -n "$neighbor_uuids" ]; then
        for uuid in $neighbor_uuids; do
            # Get neighbor address
            neighbor_addr=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".address" 2>/dev/null)
            
            if [ "$neighbor_addr" = "$target_address" ]; then
                found_uuid="$uuid"
                
                # Check remote_as_mode (Use Remote AS Number should be selected)
                remote_as_mode=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".remote_as_mode.\"\".selected" 2>/dev/null)
                if [ "$remote_as_mode" != "1" ]; then
                    needs_update=1
                    break
                fi
                
                # Check remoteas
                remoteas=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".remoteas" 2>/dev/null)
                if [ "$remoteas" != "65000" ]; then
                    needs_update=1
                    break
                fi
                # Check multihop
                multihop=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".multihop" 2>/dev/null)
                if [ "$multihop" != "1" ]; then
                    needs_update=1
                    break
                fi
                # Check peergroup (RS should be selected, None should not be)
                peergroup_none=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".peergroup.\"\".selected" 2>/dev/null)
                peergroup_rs=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".peergroup.\"$EXPECTED_PEERGROUP\".selected" 2>/dev/null)
                if [ "$peergroup_none" != "0" ] || [ "$peergroup_rs" != "1" ]; then
                    needs_update=1
                    break
                fi
                # All checks passed
                echo "BGP neighbor ${target_address} is correctly configured"
                break
            fi
        done
    fi
    # Delete existing neighbor if found but incorrect
    if [ -n "$found_uuid" ] && [ "$needs_update" = "1" ]; then
        echo "Deleting incorrect BGP neighbor: $found_uuid ($target_address)"
        curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/bgp/del_neighbor/${found_uuid}"
        sleep 1
        bgp_changed=1
        found_uuid=""
    fi
    # Create neighbor if it doesn't exist or was deleted
    if [ -z "$found_uuid" ] || [ "$needs_update" = "1" ]; then
        echo "Creating BGP neighbor ${target_address}"
        curl -k -u "$KEY":"$SECRET" -H "Content-Type: application/json" -X POST "https://127.0.0.1:8087/api/quagga/bgp/add_neighbor" --data-raw "{\"neighbor\":{\"address\":\"2600:3c0f:${REGIONID}:34::${peer_num}\",\"remoteas\":\"65000\",\"remote_as_mode\":\"\",\"description\":\"${peer_num}\",\"multihop\":\"1\",\"peergroup\":\"${EXPECTED_PEERGROUP}\"}}"
        sleep 1
        bgp_changed=1
    fi
}
# Validate/create all 4 BGP neighbors
validate_bgp_neighbor "1"
validate_bgp_neighbor "2"
validate_bgp_neighbor "3"
validate_bgp_neighbor "4"
# Clean up neighbors from other regions
neighbor_uuids=$(echo "$bgp_response" | jq -r '.bgp.neighbors.neighbor | keys[]' 2>/dev/null)

if [ -n "$neighbor_uuids" ]; then
    for uuid in $neighbor_uuids; do
        neighbor_addr=$(echo "$bgp_response" | jq -r ".bgp.neighbors.neighbor.\"$uuid\".address" 2>/dev/null)
#Check if address matches the pattern 2600:3c0f:XXXX:34::
        if echo "$neighbor_addr" | grep -qE "^2600:3c0f:[0-9a-fA-F]{1,4}:34::"; then
            # Extract the region ID from the address
            addr_region=$(echo "$neighbor_addr" | cut -d: -f3)
            ###Delete Linode BGP Peers from non-current region 
            if [ "$addr_region" != "$REGIONID" ]; then
                echo "Deleting BGP neighbor from different region: $uuid ($neighbor_addr)"
                curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/bgp/del_neighbor/${uuid}"
                sleep 1
                bgp_changed=1
            fi
        fi
    done
fi

# Apply BGP configuration changes only if something changed
if [ "$bgp_changed" = "1" ]; then
    echo "Applying BGP configuration changes..."
    curl -k -X POST -u "$KEY":"$SECRET" "https://127.0.0.1:8087/api/quagga/service/reconfigure"
else
    echo "No BGP configuration changes needed"
fi
##END BGP API CALLS

###MODIFYING CONFIG DIRECTLY BELOW
log_msg "Updating configuration file..." 
# Create temporary file for modifications
TMP_FILE=$(mktemp)
cp "$CONFIG_FILE" "$TMP_FILE"
    
# HOSTNAME CHANGES 
####LAN IP CHANGES###    
sed -i '' "/<lan>/,/<\/lan>/ s|<subnet>[0-9]*</subnet>|<subnet>${BITS}</subnet>|" "$TMP_FILE"
sed -i '' "/<lan>/,/<\/lan>/ s|<ipaddr>[^<]*</ipaddr>|<ipaddr>${LAN_IP}</ipaddr>|" "$TMP_FILE"

###Compare to current configuration
# Compare TMP_FILE with original config
if cmp -s "$TMP_FILE" "$CONFIG_FILE"; then
    echo "No configuration changes detected. Discarding temp file."
    rm -f "$TMP_FILE"
    config_changed=0
else
    echo "Configuration changes detected. Updating config."
    mv "$TMP_FILE" "$CONFIG_FILE"
    config_changed=1
fi
if [ "$config_changed" = "1" ]; then
    echo "Reloading all services..."
    /usr/local/etc/rc.reload_all
else
    echo "No reload required."
fi
log_msg "Configuration updated successfully"
log_msg "Summary:"
log_msg "  This Firewall is: ${HOSTNAME}"
log_msg "  Mode: $MODE"
log_msg "  CIDR: $CIDR"
log_msg "  Network: $NETWORK"
log_msg "  Mask: $MASK"
log_msg "  LAN IP Address: $LAN_IP"
log_msg "  Active IP: $ACTIVEIP"
log_msg "  Region: $REGION (ID: $REGIONID)"
log_msg "  Shared IP: $EXT_VIP"
log_msg "Metadata configuration complete"

exit 0
