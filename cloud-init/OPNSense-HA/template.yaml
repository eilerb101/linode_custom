#cloud-config

write_files:
  - path: /root/image-conversion.sh
    permissions: '0755'
    content: |
      #!/bin/sh
      set -x
      
      TOKEN="##TOKEN##"
      REGION="##REGION##"
      INSTANCE_ROLE="##INSTANCE_ROLE##"
      SHARED_IPV4="##SHARED_IPV4##"
      BUCKET_NAME="##BUCKET_NAME##"
      IMAGE_NAME="##IMAGE_NAME##"
      BUCKET_REGION="##BUCKET_REGION##"
      BUCKET_KEY="##BUCKET_KEY##"
      BUCKET_SECRET="##BUCKET_SECRET##"
      BUCKET_ENDPOINT="##BUCKET_ENDPOINT##"
      
      LOG_FILE="/var/log/image-conversion.log"
      API_BASE="https://api.linode.com/v4"
      MAX_RETRIES=150
      RETRY_DELAY=5
      
      log() {
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
      }
      
      api_call() {
          local method="$1"
          local url="$2"
          local data="$3"
          local attempt=0
          local response
          local http_code
          
          while [ $attempt -lt $MAX_RETRIES ]; do
              attempt=$((attempt + 1))
              
              if [ -z "$data" ]; then
                  response=$(curl -s -w "\n%{http_code}" -X "$method" \
                      -H "Authorization: Bearer $TOKEN" \
                      -H "Content-Type: application/json" \
                      "$url")
              else
                  response=$(curl -s -w "\n%{http_code}" -X "$method" \
                      -H "Authorization: Bearer $TOKEN" \
                      -H "Content-Type: application/json" \
                      -d "$data" \
                      "$url")
              fi
              
              http_code=$(echo "$response" | tail -n1)
              response=$(echo "$response" | sed '$d')
              
              if [ "$http_code" = "429" ]; then
                  log "Rate limit hit (attempt $attempt/$MAX_RETRIES). Waiting ${RETRY_DELAY}s before retry..."
                  sleep $RETRY_DELAY
                  continue
              fi
              
              if echo "$response" | grep -iq "busy\|rate limit"; then
                  log "Linode busy or rate limited (attempt $attempt/$MAX_RETRIES). Waiting ${RETRY_DELAY}s before retry..."
                  sleep $RETRY_DELAY
                  continue
              fi
              
              if echo "$response" | grep -q "\"errors\""; then
                  if [ $attempt -lt $MAX_RETRIES ]; then
                      log "API error on attempt $attempt/$MAX_RETRIES. Waiting ${RETRY_DELAY}s before retry..."
                      log "Response: $response"
                      sleep $RETRY_DELAY
                      continue
                  else
                      log "ERROR: Max retries reached. Last response: $response"
                      echo "$response"
                      return 1
                  fi
              fi
              
              echo "$response"
              return 0
          done
          
          log "ERROR: Max retries ($MAX_RETRIES) reached"
          return 1
      }
      
      log "=== Starting Image Conversion Process ==="
      
      log "Acquiring metadata service access token..."
      ACCESS=$(curl -s -X PUT -H "Metadata-Token-Expiry-Seconds: 3600" http://169.254.169.254/v1/token)
      if [ -z "$ACCESS" ]; then
          log "ERROR: Failed to acquire metadata access token"
          exit 1
      fi
      log "Metadata access token acquired"
      
      log "Discovering instance ID from metadata service..."
      instance_data=$(curl -s -H "Metadata-Token: $ACCESS" http://169.254.169.254/v1/instance)
      INSTANCE_ID=$(echo "$instance_data" | grep "^id:" | awk '{print $2}')
      if [ -z "$INSTANCE_ID" ]; then
          log "ERROR: Failed to discover instance ID"
          log "Metadata response: $instance_data"
          exit 1
      fi
      log "Instance ID: $INSTANCE_ID"
      
      log "Bucket: $BUCKET_NAME"
      log "Image: $IMAGE_NAME"
      log "Region: $REGION"
      log "Token: $TOKEN"
      log "Instance Role: $INSTANCE_ROLE"
      log "Shared IPv4 Address: $SHARED_IPV4"
      log "Bucket Region: $BUCKET_REGION"
      log "Bucket Key: $BUCKET_KEY" 
      log "Bucket Secret: $BUCKET_SECRET" 
      log "Bucket Endpoint: $BUCKET_ENDPOINT"
      # If standby, delay startup to avoid IP sharing conflicts
      if [ "$INSTANCE_ROLE" = "standby" ]; then
          log "Standby instance detected - waiting 180 seconds before proceeding..."
          sleep 300
          log "Wait complete, proceeding with conversion..."
      fi
      log "Installing qemu-utils and s3fs..."
      apk update
      apk add qemu-img s3fs-fuse curl jq util-linux
      INSTALL_DISK=$(lsblk -b -dn -o NAME,SIZE | sort -k2 -nr | head -n1 | awk '{print "/dev/" $1}')
      log "Install target disk: $INSTALL_DISK"
      log "Fetching Linode configuration list..."
      config_attempts=0
      max_config_attempts=20  # 20 attempts * 30 seconds = 10 minutes
      configs=""

      while [ $config_attempts -lt $max_config_attempts ]; do
          config_attempts=$((config_attempts + 1))
          log "Config fetch attempt $config_attempts/$max_config_attempts..."
    
          configs=$(api_call "GET" "${API_BASE}/linode/instances/${INSTANCE_ID}/configs")
    
          if [ $? -ne 0 ] || echo "$configs" | grep -q "\"errors\""; then
              log "ERROR: Failed to fetch Linode configs"
              log "Response: $configs"
              exit 1
          fi
    
          log "$configs"
    
          # Check if we have results
          results=$(echo "$configs" | jq -r '.results')
    
          if [ "$results" -ge 2 ]; then
              log "Found $results configs, proceeding..."
              break
          else
              log "Only found $results configs, waiting 30 seconds before retry..."
              sleep 30
          fi
      done

      if [ "$config_attempts" -ge "$max_config_attempts" ]; then
          log "ERROR: Timeout waiting for configs to be created"
          log "Last response: $configs"
          exit 1
      fi
      ALPINE_CONFIG=$(echo "$configs" | jq -r '.data[] | select(.label | test("Alpine"; "i")) | .id' | head -n1)
      log "Alpine Config: $ALPINE_CONFIG"
      WINDOWS_CONFIG=$(echo "$configs" | jq -r '.data[] | select(.label | test("System"; "i")) | .id' | head -n1)
      log "Windows Config: $WINDOWS_CONFIG"
      if [ -z "$ALPINE_CONFIG" ] || [ "$ALPINE_CONFIG" = "null" ]; then
          log "ERROR: Could not find config labeled 'Alpine'"
          log "Configs available: $(echo "$configs" | jq -r '.data[].label')"
          exit 1
      fi
      
      if [ -z "$WINDOWS_CONFIG" ] || [ "$WINDOWS_CONFIG" = "null" ]; then
          log "ERROR: Could not find config labeled containing 'System'"
          log "Configs available: $(echo "$configs" | jq -r '.data[].label')"
          exit 1
      fi
      
      log "Discovered Alpine Config ID: $ALPINE_CONFIG"
      log "Discovered Windows Config ID: $WINDOWS_CONFIG"
      
      modprobe fuse
      
      log "Creating S3FS credentials file..."
      echo "${BUCKET_KEY}:${BUCKET_SECRET}" > /etc/.s3fs-passwd
      chmod 400 /etc/.s3fs-passwd
      
      log "Creating mount point /s3..."
      mkdir -p /s3
      
      log "Mounting bucket ${BUCKET_NAME} from ${BUCKET_REGION}..."
      
      s3fs "$BUCKET_NAME" /s3 \
          -o passwd_file=/etc/.s3fs-passwd \
          -o url=https://${BUCKET_ENDPOINT} \
          -o use_path_request_style \
          -o ro
      
      if [ $? -ne 0 ]; then
          log "ERROR: Failed to mount S3 bucket"
          exit 1
      fi
      
      log "Successfully mounted bucket"
      
      log "Checking for image file: $IMAGE_NAME"
      if [ ! -f "/s3/$IMAGE_NAME" ]; then
          log "ERROR: Image file /s3/$IMAGE_NAME not found"
          log "Contents of /s3:"
          ls -lh /s3 | tee -a "$LOG_FILE"
          exit 1
      fi
      
      log "Image file found: /s3/$IMAGE_NAME"
      IMAGE_SIZE=$(stat -c %s "/s3/$IMAGE_NAME")
      IMAGE_SIZE_GB=$((IMAGE_SIZE / 1024 / 1024 / 1024))
      log "Image size: ${IMAGE_SIZE} bytes (${IMAGE_SIZE_GB} GB)"
      
      if [ ! -b "$INSTALL_DISK" ]; then
          log "ERROR: Target disk $INSTALL_DISK not found"
          exit 1
      fi
      
      DISK_SIZE=$(blockdev --getsize64 "$INSTALL_DISK")
      DISK_SIZE_GB=$((DISK_SIZE / 1024 / 1024 / 1024))
      log "Target disk $INSTALL_DISK size: ${DISK_SIZE} bytes (${DISK_SIZE_GB} GB)"
      
      log "Checking actual image virtual size..."
      VIRTUAL_SIZE=$(qemu-img info "/s3/$IMAGE_NAME" | grep "virtual size" | awk '{print $3}')
      VIRTUAL_SIZE_BYTES=$(qemu-img info --output=json "/s3/$IMAGE_NAME" | jq -r '.["virtual-size"]')
      log "Image virtual size: ${VIRTUAL_SIZE_BYTES} bytes"
      if [ "$VIRTUAL_SIZE_BYTES" -gt "$DISK_SIZE" ]; then
          log "ERROR: Image virtual size (${VIRTUAL_SIZE_BYTES} bytes) exceeds target disk size (${DISK_SIZE} bytes)"
          exit 1
      fi
      log "Image will fit on target disk"
      
      log "Detecting image format..."
      IMAGE_FORMAT=$(qemu-img info --output=json "/s3/$IMAGE_NAME" | jq -r '.format')
      log "Detected image format: $IMAGE_FORMAT"
      
      if [ "$IMAGE_FORMAT" = "raw" ]; then
          log "Image is already in RAW format, using dd for direct copy..."
          log "Source: /s3/$IMAGE_NAME"
          log "Destination: $INSTALL_DISK"
          log "This may take a while..."
          dd if="/s3/$IMAGE_NAME" of="$INSTALL_DISK" bs=4M
          if [ $? -ne 0 ]; then
              log "ERROR: dd copy failed"
              exit 1
          fi
          log "Image copy completed successfully"
      
      elif echo "$IMAGE_FORMAT" | grep -Eq '^(qcow|qcow2|vmdk|vdi|vhd|vhdx)$'; then
          log "Starting image conversion from $IMAGE_FORMAT to RAW..."
          log "Source: /s3/$IMAGE_NAME"
          log "Destination: $INSTALL_DISK"
          log "This may take a while..."
          qemu-img convert -p -f "$IMAGE_FORMAT" -O raw -W "/s3/$IMAGE_NAME" "$INSTALL_DISK"
          if [ $? -ne 0 ]; then
              log "ERROR: Image conversion failed"
              exit 1
          fi
          log "Image conversion completed successfully"
      
      else
          log "ERROR: Unsupported image format: $IMAGE_FORMAT"
          log "Supported formats: raw, qcow, qcow2, vmdk, vdi, vhd, vhdx"
          exit 1
      fi
      
      sync
      log "Data synced to disk"
      
      log "Unmounting S3 bucket..."
      umount /s3
      
      log "Deleting Alpine configuration (ID: $ALPINE_CONFIG)..."
      delete_response=$(api_call "DELETE" "${API_BASE}/linode/instances/${INSTANCE_ID}/configs/${ALPINE_CONFIG}")
      
      if [ $? -ne 0 ] || echo "$delete_response" | grep -q "error"; then
          log "WARNING: Failed to delete Alpine configuration"
          log "Response: $delete_response"
      else
          log "Alpine configuration deleted successfully"
      fi
      # If this is the standby instance, share the IP before rebooting
      if [ "$INSTANCE_ROLE" = "standby" ] && [ "$SHARED_IPV4" != "0.0.0.0" ]; then
          log "This is the standby instance - sharing IP $SHARED_IPV4..."
          share_payload="{\"ips\":[\"$SHARED_IPV4\"],\"linode_id\":$INSTANCE_ID}"
          share_response=$(api_call "POST" "${API_BASE}/networking/ips/share" "$share_payload")
          if [ $? -ne 0 ] || echo "$share_response" | grep -q "\"errors\""; then
              log "ERROR: Failed to share IP address"
              log "Response: $share_response"
        # Don't exit - continue with reboot anyway
          else
              log "IP address $SHARED_IPV4 shared successfully with this instance"
          fi
      else
          log "This is the active instance or no valid IP to share - skipping IP sharing"
      fi
      
      log "Booting OPNSense configuration (ID: $WINDOWS_CONFIG)..."
      boot_response=$(api_call "POST" "${API_BASE}/linode/instances/${INSTANCE_ID}/reboot")
      
      if [ $? -ne 0 ] || echo "$boot_response" | grep -q "error"; then
          log "ERROR: Failed to boot OPNSense configuration"
          log "Response: $boot_response"
          exit 1
      fi
      
      log "OPNSense configuration boot initiated"
      log "=== Image Conversion Process Complete ==="
      log "The system will now reboot into the OPNSense configuration"
      
      exit 0

runcmd:
  - /root/image-conversion.sh > /var/log/cloud-init-script.log 2>&1
